\paragraph*{Acceleration\\}
In general, as the subdivision depth increases, the step size provided by our algorithm also becomes larger. However, in practical cases, a tetrahedron tends to flip at one of its four vertices first. When this happens, one of the subdivided sub-tetrahedra will inherit that vertex, and the corresponding cubic polynomial will be identical to that of the parent tetrahedron. Thus, the step size computed after subdivision will not be larger than that obtained without subdivision. Since subdivision is computationally expensive, this results in a performance inefficiency.

To address this, an acceleration strategy is to first compute the step size based on the cubic polynomials at the four vertices (sampling points). Then, using this step size, we can check if any other sampling points lead to a flip. If none of them do, subdivision becomes unnecessary, and the algorithm can terminate early. If a flip occurs, we then consider whether further subdivision is needed based on the situation.

Federico[2023] mentions a useful acceleration strategy, which involves detecting the tetrahedron that is most prone to flipping first during serial computation. It records the step size calculated from the earlier tetrahedra and uses it as the input for the subsequent ones. We also employ this strategy. Additionally, we found that for many tetrahedra, the input step size is often already a valid step size. Therefore, using the method from Paper A directly proves to be more efficient. Thus, we apply Federico's method as a filtering step and use our method later.

\paragraph*{Evaluation\\}
Our method is numerically accurate and reliable. Firstly, the basis function transformations and subdivisions in our algorithm involve direct matrix multiplication. We precompute these matrices using Mathematica and store them as interval numbers to ensure their accuracy. Secondly, Our algorithm uses Newton's method along with necessary subdivisions to accurately compute the step size. Thirdly, we have demonstrated that by ensuring certain cubic polynomials remain positive, we can guarantee that the tetrahedron will not flip. By using a case-based root-finding combined with a conservative Newton method, we theoretically ensure that the roots of the cubic polynomials are greater than the lower bounds of the interval values we compute. Using the lower bound of the interval number directly guarantees that the tetrahedron remains non-flipped in numerical calculations.